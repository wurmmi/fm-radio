%%%%%%%%%%%%%%%%%%%%
\chapter{System Design Process}
\label{cha:SystemDesignProcess}

The process of system design is a central topic in the development of any product.
This chapter describes general techniques for system design.
However, they can also be directly applied to FPGA design.
Additionally, tools that are specifically used in FPGA design are introduced.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{General}

The following sections describe a generalized approach to system design.
A process called SIMILAR is explained, as well as selected topics that are relevant.
The researched information for this section is mainly based on \cite{BahillA.Terry2017TDiS}.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The SIMILAR Process}
%TODO: maybe include additional facts from https://slideplayer.com/slide/14327503/

The SIMILAR process provides a general approach to problem solving.
It can be applied to any kind of problem that can be of technical, as well as non-technical nature, in order to successfully achieve the specified requirements.
The concept was developed by A.T. Bahill and B. Gissing, who evaluated and compared multiple existing processes to find their similarities.\\

The acronym SIMILAR consists of the following components.

\begin{itemize}
  \item \textbf{S}tate the Problem
  \item \textbf{I}nvestigate Alternatives
  \item \textbf{M}odel the System
  \item \textbf{I}ntegrate Components
  \item \textbf{L}aunch the System
  \item \textbf{A}ssess Performance
  \item \textbf{R}e-evaluate
\end{itemize}

Each of these terms represents a separate step in the process diagram shown in Fig.\ref{fig:similar_process}.
The steps can be seen as iterative and parallel, as the process runs during the product development cycle.

\includepicture [0.95] [0] {The SIMILAR process in a graphical representation \cite{BahillA.Terry2017TDiS}.} {similar_process} {img/draw.io/similar_process}

%%%%%
\subsubsection{State the Problem}

The very first step of the process is to state the problem that is to be solved.
This can be the initial definition of a new product, but can also be the definition of an improvement that is to be made for an existing product.
Because of that, input for the problem statement can be generated by various parties, such as customers, product developers, regulatory agencies or manufacturers, just to name a few.
In the process diagram, all these possible input parties are labeled as stakeholders.\\

Generally speaking, the problem statement serves the purpose to build a common understanding of the problem between a stakeholder and the developer.
In case there is a mismatch, an engineer may spend valuable time to develop a sophisticated solution to a problem that was not even a requirement.
Thus, any time spent to develop this feature is worthless, which highlights the importance of a correct problem statement.\\

An important guideline for the specification of this problem statement is, that each requirement is descibed in the way of \textit{what} needs to be done, not \textit{how} it needs to be done.\\

The problem statement is updated and improved by the Re-evaluate step, which is described later.

%%%%%
\subsubsection{Investigate Alternatives}

In almost any kind of problem, there are multiple ways in order to achieve a successful solution.
However, some solutions may be preferred over others because of certain criteria that are evaluated.
Such criteria may be cost, risk, schedule or performance.
Based on the combined evaluation of these factors, a decision in favor of one selected alternative is made.
This part of the process is also called concept exploration.\\

It is important to note that this step is a repeated, iterative step.
This is necessary, since there may only be a few known facts available at the initial intestigation.
Further design steps, such as a first estimation of the intended design implementation, simulation results, or a prototype can provide more data and facts.
These can be used to re-evaluate the alternatives and consequently optimize the design process.


%%%%%
\subsubsection{Model the System}

Based on the previous steps, a model for the system is developed here.
This includes a process model, that is used for stragetic planning towards cost reduction, optimization of the implementation effort, or the schedule of subprojects, and a product model, which supports trade-offs and the identification of risks, or helps to explain the system as a whole.\\

Typically, a coarse model is created for almost all alternative designs that were found in the previous step.
A more detailed model is developed for the single, selected design.
The model itself may be represented in many different ways, such as state machines, block diagrams, flow diagrams, simulations or object-oriented diagrams.

%%%%%
\subsubsection{Integrate Components}

This step combines multiple single components into a larger, integrated system, which can then be treated as a whole.
In order to be able to do that, interfaces between the components and subsystems need to be defined.
Optimally, these interfaces are designed in a way that the amount of data that needs to be exchanged is kept to a minimum.
It is of advantage, if a subsystem only transfers finished products that it produced to another subsystem.
The aim to develop simple interfaces is of special advantage in systems that include a feedback loop.
There, managing the feedback loop connections is easier if there is a clear interface, so the loop can be connected around an entire subsystem, instead of interconnecting within the subsystems.

%%%%%
\subsubsection{Launch the System}

The system launch actually runs the system in a defined environment, so that it can perform what it is intended and designed to do.
The defined environment can be the final, operational environment, or just a simulation which provides an output that is detailed enough for an evaluation.
In a product that involves hardware development, this step may include the installation of commercial off-the-shelf products with a modified prototype software.
However, since the SIMILAR process is applicable for any kind of problem, this might also be a business process, where the launch step may be the roll-out of the subprocesses and tasks in the respective departments of a company.

%%%%%
\subsubsection{Assess Performance}

This step is all about measurements.
The performance of a system can only be evaluated, if it can be measured by using different metrics.
Evaluation criteria are used, based on the measurements of the technical performance, which can help to find trade-offs or to mitigate risk in design and manufacturing.

%%%%%
\subsubsection{Re-evaluate}

The re-evaluate step is a central building block in the SIMILAR concept.
All of the other steps have a connection to it, in the form of a feedback loop.
However, depending on the nature of the project and the point in the timeline of its life cycle, not all of these loops may be exercised all the time.
The idea of re-evaluation and the subsequent improvement of a process is a widely applied and well-known concept.
Its main function is to observe an output and to use this information to improve the systems' input.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Design for Reuse}

A design principle that is often used is design for reuse.
It enables a faster and more efficient development of products, which leads to an overall decrease in development cost.
Additionally, the product is likely less error-prone, since the reused parts of the system are already tested at this point.
After all these positive arguments, there is a counter argument to it, though: designing a system with reuseable subsystems comes with cost.
Additional effort is required to design the subsystems in a way so that they can be reused in another project.
However, this additional effort may potentially already be paid off, when a single subsystem can be reused in a future product and thus, it is worth the effort.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Validation and Verification}
\label{sec:ValidationAndVerification}

The terms validation and verification are closely related, but have a different meaning in system design.
Verification tests the properties of the developed product against the previously determined specification and requirements.
It stives to build the \textit{system right}.
Validation on the other hand tries to build the \textit{right system}.
It proves that the product does what it is intended to do.
This is important in order to develop the product according to what the customer actually needs.
To avoid to divert from these customer needs, validation is done throughout the products' development cycle, from the beginning to the end.
Various artifacts can be collected during the process, in order to have a traceable documentation of the decision that were made.\\

Validation may also fail, which means that the chosen system may be the wrong system for the respective customers needs.
As an example, the system may be very sensitive to variations of a parameter that a customer cannot influence.
Another example is when a system is more sensitive to certain parameters than to its inputs.
In both cases, the system may be the wrong system for the specific problem and should urgently be re-evaluated.\\

In order to expose such failures as early as possible, any test engineer should be instructed to always keep an eye on the process of validation, which means to check if the team is building the \textit{right system}.
Therefore, a test engineer should be familiar with the problem statement.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System Design Targeting FPGAs}

A wide range of system-level design approaches are available that are targeting FPGAs.
In this section, some selected approaches are described.
The research for this section is mainly based on \cite{GesslerRalf2014EES}.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{V-Modell}

The development of a product requires an organized approach, in order to successfully achieve the requirements.
The common term for such an organized approach is the process model, which represents a guideline on how to organize and structure the development cycle.\\

A well-known process model is the so called V-Model.
It is based on the similarly well-known Waterfall Model, and has its name because of the distinct V-shape of its process diagram, as it is shown in Fig.\ref{fig:v_modell}.
One of the main characteristics of the V-Model is, that one phase needs to be completed before the following phase can start.
This classifies the model as a static process model and is one of the main disadvantages at the same time, because it makes the model inflexible to adaptions of the requirements.
The advantages however are that it is easy to install and apply, each phase has its specific deliverables, good results can be achieved for large projects with simple requirements and the early test phases.\\

The disadvantages of inflexibility towards changes of requirements and the fact, that it is difficult to consider all all eventualities in the creation of the V-model, led to the innovation of modern process models, which are iterative and thus more flexible.\\

The V-model applies to general software development, or project development, but can directly be mapped to FPGA development.
The model is covered in this thesis section, because it shows the clear testing structure of module tests (unit tests), integration tests and system tests, which is especially important in projects that target hardware, such as FPGA projects.\\

Furthermore, the V-model diagram in Fig.\ref{fig:v_modell} shows the difference between validation and verification, as it is explained in the previous section \ref{sec:ValidationAndVerification}.

\includepicture [1.0] [0] {The V-Modell process diagram \cite[Abbildung 3.5]{GesslerRalf2014EES}.} {v_modell} {img/draw.io/v_modell}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{High-Level Synthesis}

High-Level Synthes (HLS) is an FPGA design methodology that provides a high level of abstraction, and thus can be seen as a system level design method.
Different languages are used for HLS - two well-known languages are SystemC, which is a library for \cplusplus\ to provide modelling and simulation features, and plain \cplusplus.
A comprehensive list of available HLS tools and languages can be found in Section 3.3 of \cite{2016FfSP}.\\

The main idea of HLS is, that the hardware design can be written in abstract modules, that represent the actual functional meaning of a feature or algorithm, rather than the complex, low-level hardware details.
HLS achieves this by allowing to develop the code in a high-level language, such as \cplusplus.
This high-level code is then automatically transformed into hardware description language (HDL) by the respective HLS tool.\\

In this thesis, only the HLS of plain \cplusplus\ is covered.
SystemC is not discussed, since it may potentially be less important in the future.
In the latest Xilinx HLS tools 'Vitis HLS' and 'Vivado HLS', the language SystemC is already deprecated \cite{VivadoHlsSystemC}.\\

\noindent
HLS is described into more detail in Chapter \ref{cha:HLS}.


%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Direct Implementation}

The implementation of low-level hardware description language (HDL) in the register transfer level (RTL) is denoted as 'direct', or 'manual' implementation in this thesis.\\

Two commonly used languages therefor are VHDL and Verilog.
Both have similar features to describe hardware in the signal level, with parallel structures and timing-dependent architectures.
The languages can describe a design in a hierarchical order, so that the separate modules can be constructed in a way that an overview of the functionality of the system remains given.
Synthesis, as well as simulation is supported, which allows efficient development of RTL designs.\\

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementation with Tool Support}
see \cite{GesslerRalf2014EES}\\

Matlab Simulink System Generator\\
Matlab Simulink HDL Coder\\

In Fig.\ref{fig:fpga_design_levels}, multiple implementation methods are compared, with their respective levels of abstraction.

\includepicture [0.5] [0] {Abstraction levels of the different implementation languages \cite[Abbildung 5.1]{GesslerRalf2014EES}.} {fpga_design_levels} {img/fpga_design_levels}
