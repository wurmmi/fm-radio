%%%%%%%%%%%%%%%%%%%%
\chapter{System Design Process}
\label{cha:SystemDesignProcess}

The process of system design is a central topic in the development of any product.
This chapter describes general techniques for system design.
However, they can also be directly applied to FPGA design.
Additionally, tools that are specifically used in FPGA design are introduced.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{General}

The following sections describe a generalized approach to system design.
A process called SIMILAR is explained, as well as selected topics that are relevant.
The researched information for this section is mainly based on \cite{BahillA.Terry2017TDiS}.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The SIMILAR Process}
%TODO: maybe include additional facts from https://slideplayer.com/slide/14327503/

The SIMILAR process provides a general approach to problem solving.
It can be applied to any kind of problem that can be of technical, as well as non-technical nature, in order to successfully achieve the specified requirements.
The concept was developed by A.T. Bahill and B. Gissing, who evaluated and compared multiple existing processes to find their similarities.\\

The acronym SIMILAR consists of the following components.

\begin{itemize}
  \item \textbf{S}tate the Problem
  \item \textbf{I}nvestigate Alternatives
  \item \textbf{M}odel the System
  \item \textbf{I}ntegrate Components
  \item \textbf{L}aunch the System
  \item \textbf{A}ssess Performance
  \item \textbf{R}e-evaluate
\end{itemize}

Each of these terms represents a separate step in the process diagram shown in Fig.\ref{fig:similar_process}.
The steps can be seen as iterative and parallel, as the process runs during the product development cycle.

\includepicture [0.7] [0] {The SIMILAR process in a graphical representation.} {similar_process} {img/similar_process}

%%%%%
\subsubsection{State the Problem}

The very first step of the process is to state the problem that is to be solved.
This can be the initial definition of a new product, but can also be the definition of an improvement that is to be made for an existing product.
Because of that, input for the problem statement can be generated by various parties, such as customers, product developers, regulatory agencies or manufacturers, just to name a few.
In the process diagram, all these possible input parties are labeled as stakeholders.\\

Generally speaking, the problem statement serves the purpose to build a common understanding of the problem between a stakeholder and the developer.
In case there is a mismatch, an engineer may spend valuable time to develop a sophisticated solution to a problem that was not even a requirement.
Thus, any time spent to develop this feature is worthless, which highlights the importance of a correct problem statement.\\

An important guideline for the specification of this problem statement is, that each requirement is descibed in the way of \textit{what} needs to be done, not \textit{how} it needs to be done.\\

The problem statement is updated and improved by the Re-evaluate step, which is described later.

%%%%%
\subsubsection{Investigate Alternatives}

In almost any kind of problem, there are multiple ways in order to achieve a successful solution.
However, some solutions may be preferred over others because of certain criteria that are evaluated.
Such criteria may be cost, risk, schedule or performance.
Based on the combined evaluation of these factors, a decision in favor of one selected alternative is made.
This part of the process is also called concept exploration.\\

It is important to note that this step is a repeated, iterative step.
This is necessary, since there may only be a few known facts available at the initial intestigation.
Further design steps, such as a first estimation of the intended design implementation, simulation results, or a prototype can provide more data and facts.
These can be used to re-evaluate the alternatives and consequently optimize the design process.


%%%%%
\subsubsection{Model the System}

Based on the previous steps, a model for the system is developed here.
This includes a process model, that is used for stragetic planning towards cost reduction, optimization of the implementation effort, or the schedule of subprojects, and a product model, which supports trade-offs and the identification of risks, or helps to explain the system as a whole.\\

Typically, a coarse model is created for almost all alternative designs that were found in the previous step.
A more detailed model is developed for the single, selected design.
The model itself may be represented in many different ways, such as state machines, block diagrams, flow diagrams, simulations or object-oriented diagrams.

%%%%%
\subsubsection{Integrate Components}

This step combines multiple single components into a larger, integrated system, which can then be treated as a whole.
In order to be able to do that, interfaces between the components and subsystems need to be defined.
Optimally, these interfaces are designed in a way that the amount of data that needs to be exchanged is kept to a minimum.
It is of advantage, if a subsystem only transfers finished products that it produced to another subsystem.
The aim to develop simple interfaces is of special advantage in systems that include a feedback loop.
There, managing the feedback loop connections is easier if there is a clear interface, so the loop can be connected around an entire subsystem, instead of interconnecting within the subsystems.

%%%%%
\subsubsection{Launch the System}

The system launch actually runs the system in a defined environment, so that it can perform what it is intended and designed to do.
The defined environment can be the final, operational environment, or just a simulation which provides an output that is detailed enough for an evaluation.
In a product that involves hardware development, this step may include the installation of commercial off-the-shelf products with a modified prototype software.
However, since the SIMILAR process is applicable for any kind of problem, this might also be a business process, where the launch step may be the roll-out of the subprocesses and tasks in the respective departments of a company.

%%%%%
\subsubsection{Assess Performance}

This step is all about measurements.
The performance of a system can only be evaluated, if it can be measured by using different metrics.
Evaluation criteria are used, based on the measurements of the technical performance, which can help to find trade-offs or to mitigate risk in design and manufacturing.

%%%%%
\subsubsection{Re-evaluate}

The re-evaluate step is a central building block in the SIMILAR concept.
All of the other steps have a connection to it, in the form of a feedback loop.
However, depending on the nature of the project and the point in the timeline of its life cycle, not all of these loops may be exercised all the time.
The idea of re-evaluation and the subsequent improvement of a process is a widely applied and well-known concept.
Its main function is to observe an output and to use this information to improve the systems' input.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Design for Reuse}

A design principle that is often used is design for reuse.
It enables a faster and more efficient development of products, which leads to an overall decrease in development cost.
Additionally, the product is likely less error-prone, since the reused parts of the system are already tested at this point.
After all these positive arguments, there is a counter argument to it, though: designing a system with reuseable subsystems comes with cost.
Additional effort is required to design the subsystems in a way so that they can be reused in another project.
However, this additional effort may potentially already be paid off, when a single subsystem can be reused in a future product and thus, it is worth the effort.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Validation and Verification}

The terms validation and verification are closely related, but have a different meaning in system design.

Validation fulfils the purpose to prove that the developed product does what it is intended to do.
It strives to build the \textit{right system}.
Verification on the other hand tries to build the \textit{system right}, by testing its properties against the previously determined specification and requirements.\\



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{System Design Targeting FPGAs}
The research for this chapter is mainly based on \cite{GesslerRalf2014EES}.
%https://link-springer-com.fhooe.idm.oclc.org/content/pdf/10.1007%2F978-3-319-26408-0.pdf
%chapter 3

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{V-Modell}

%applies to general software development, but can directly be mapped to FPGA development.

%Abbildung 3.5 in
%https://link-springer-com.fhooe.idm.oclc.org/content/pdf/10.1007%2F978-3-8348-2080-8.pdf

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{High-Level Synthesis}
%\cplusplus\\
%SystemC (deprecated for synthesis by Xilinx)\\

A comprehensive list of HLS tools can be found in Section 3.3 of
%https://link-springer-com.fhooe.idm.oclc.org/content/pdf/10.1007%2F978-3-319-26408-0.pdf

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementation with Tool Support}
%https://link-springer-com.fhooe.idm.oclc.org/content/pdf/10.1007%2F978-3-8348-2080-8.pdf

%Matlab Simulink System Generator\\
%Matlab Simulink HDL Coder\\

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Direct Implementation}

%direct, or 'manual' implementation\\
%VHDL/Verilog\\
