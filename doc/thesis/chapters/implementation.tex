%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
\label{cha:Implementation}

This chapter describes the most important details of each implementation variant.

\section{Digital Signal Processing Chain}

The theory behind the demodulation of an FM signal is already explained in Chapter \ref{cha:SignalProcessingTheory}.
The demodulation of an FM broadcast channel specifically, is described in Section \ref{sec:demodulation-of-broadcast-fm}.
In this section however, the DSP chain is described into more detail and with more information, as it is implemented in the various methods.\\

Fig.\ref{fig:bd_dsp_detailed} displays the detailed DSP chain as a block diagram.

\includepicture [1.02] [0] [H] {Detailed block diagram of the digital signal processing chain.} {bd_dsp_detailed} {img/draw.io/bd_dsp_detailed}

The following list explains implementation details about the respective DSP blocks.
\begin{itemize}
  \item \textbf{Data Source}\\
      Matlab is used to generate the data source file, which is used as an input to the system.
      An audio file is read and modulated as an FM channel signal.

  \item \textbf{FM Demodulator}\\
      The FM demodulator is implemented as a Baseband Delay Modulator, as described in Section \ref{sec:BasebandDelayDemodulator}.

  \item \textbf{De-Emphasis Filter}\\
      The above described Matlab source generation does not include an Emphasis filter.
      Thus, a de-emphasis filter is not implemented as it is not required.

  \item \textbf{Downsample}\\
      Downsampling is implemented in a simplified version, without an anti-aliasing filter.
      It is not required, because of the following explanation.
      At this point the sampling frequency is set to 960 kHz.
      The input is band-limited at 75 kHz, which is the maximum frequency in an FM channel, as explained in Section \ref{sec:FrequencySpectrumOfABroadcastFmChannel}.
      Thus, the input has an oversampling rate of 12.8, while downsampling is only performed with a factor of 8.

  \item \textbf{Filters}\\
      Several filters are implemented as FIR filters.
      The 15 kHz lowpass (LP) filter is instantiated twice, with the exact same coefficients.

  \item \textbf{Filter Group Delay Compensation}\\
      FIR filters introduce a delay on the output signal, with respect to the input.
      The group delay in number of samples can be computed with the following formula.
      \begin{equation}
        group\ delay = \frac{filter\ order}{2} = \frac{(N\ coefficients - 1)}{2}
      \end{equation}
      This is due to the property of the FIR filters' linear phase response \cite{GaziOrhan2018UDSP}.
      Since phase is directly proportional to time, the term \textit{group delay} is often used.
      This delay needs to be accounted for, depending on where the signal is used subsequently.

      Looking at the block diagram, the group delay needs to be compensated at two places.
      \begin{itemize}
        \item \textbf{Between the branches \textit{Recover LR diff} and \textit{Recover Mono}:}\\
          The \textit{Mono} branch only contains a single LP filter, while the \textit{LR diff} branch contains two filters, namely a BP and an LP filter.
          The latter branches' signal is therefore delayed, with respect to the \textit{Mono} branch.\\
          The issue here is, that both signals are added and substracted at the end of the processing chain, to compute the left and right channel signals, respectively.
          Thus, they need to be aligned in time at that point.
          Consequently, a delay block needs to be inserted in the \textit{Mono} branch, to compensate the group delay of the BP.

        \item \textbf{Between the branches \textit{Recover LR diff} and \textit{Recover Carriers}:}\\
          Both branches only contain a single BP filter.
          However, they have properties, like the transition bandwidth and the passband.
          Thus, their filter order may be different as well, which leads to a non-matching group delay.
          Since the two signals are multiplicated in the subsequent mixer, and an important factor is the phase-coherency of the recovered carrier (as explained in Section \ref{sec:demodulation-of-broadcast-fm}), the group delay compensation becomes necessary here.\\

          To overcome the issue at this point in the actual hardware implementation, the filters were manually 'tuned' to have a matching order.
      \end{itemize}

  \item \textbf{Carrier Recovery}\\
      The 38 kHz carrier can be recovered from the 19 kHz pilot tone.
      It is important that the recovered carrier is phase-coherent with the received input, as described in Section \ref{sec:demodulation-of-broadcast-fm}.
      This can be achieved, by simply multiplying the pilot tone with itself, which is the way it is implemented here.
\end{itemize}

\noindent
Several of the listed details are implemented, in order to achieve a successful demodulation of the FM signal.

\section{Matlab Model}

Matlab is used to create a model of the receiver, which is used as a reference for the other implementation variants.
Here, DSP algorithms are tested and evaluated, to find a method that is suitable to implement in hardware, specifically in an FPGA.

The Matlab script consists of a transmitter, the receiver model, and additional code for analysis.

\subsection{Transmitter}

The transmitter is implemented to provide a reproducable source of data, which can be used to feed the receiver.
Another option would be to use external hardware as a software-defined radio and record some antenna data.
However, the main advantage of a locally implemented transmitter over a recording is, that the raw data input is known.
Thus, the expected output of the receiver model is this raw data, that was previously modulated by the local transmitter.
In the case of a recording, the original data is not known, which does not allow to actually verify the receiver.\\

In the implemented version, an audio file is modulated into the FM channel.
The audio file contains data that represents speech with the words \textit{'Left channel... Right channel...'}.
In terms of audio channels, the words exactly match the respective channels' output - the first part is modulated on the left audio channel only, while the second part only targets the right audio channel.
This is particulary useful for verification, especially to verify the functionality of channel separation.
From the experience during development, the channel separation is a good indicator of whether the system is functioning correctly.
This left-right indication also simplifies the verification process, because a developer can recognize it with their visual and acoustic senses.
It is possible to audibly verify it by listening to the output.
It is also possible to just visually inspect the output data, where a clear separation is visible between the channels.\\

The transmitter is implemented according to the structure that is depicted as a block diagram in Fig.\ref{fig:bd_matlab_transmitter}.
To facilitate an easy understanding of the block diagram, it is of advantage to keep in mind that it exactly resembles the frequency spectrum that is previously shown in Fig.\ref{fig:fm_channel_baseband_freqs}.\\

\includepicture [1.0] [0] {Block diagram of the implemented transmitter in Matlab.} {bd_matlab_transmitter} {img/draw.io/bd_matlab_transmitter}

The transmitter reads an audio file, including a left and a right channel in the first step.
The audio file contains data in a sample rate of 48 kHz.
Next, the sample rate is increased by an oversampling factor of 20, to achieve a sufficient sample rate for the subsequent DSP procedures.

The achieved sample rate of 960 kHz could actually be chosen much lower, since an FM channels' maximum frequency is 75 kHz (see \ref{sec:FrequencySpectrumOfABroadcastFmChannel}), and according to the Nyquist theorem the sample rate thus only needs to have 150 kHz (see \ref{sec:SamplingTheorem}).
However, the higher rate was chosen, mainly because a higher number of signal samples beautify any plots that are created during analysis.
Since a thorough optimization of the DSP chain is not the focus of this thesis, this was an acceptable trade-off.

The next step is the pre-emphasis filter, which is implemented, but is disabled in the receiver.
This is done to reduce some complexity in the hardware implementation.
The following stage generates the Mono and LR Diff signals, by simply calculating the summation and diffence of the left and right channels, respectively.

The next section in the block diagram represents multiple processes in parallel.
The LR Diff part is shifted to 38 kHz in the spectrum.
This is done by modulating the signal with its sub-carrier of 38 kHz.
A subsequent BP filter serves to remove the artifacts of the modulation, such as the image replica.
It band-limits the spectrum of the LR Diff part between 23 and 53 kHz.
The BP filter introduces a constant group delay of the signal.
In order to maintain the alignment of all signals, this side-effect needs to be accounted for and be compensated in the other signal branches.
Thus, the Mono signal, as well as the Pilot Tone need to be delayed by the amount of samples defined by the BP filters' group delay.
The subsequent amplifier blocks create the defined proportions of the sub-band, such as 90\% for the audio parts, and 10\% for the Pilot Tone \cite{FmMultiplexingForStereo}.

One part in this block diagram is the so-called Hinz Triller, which was part of the Autofahrer-Rundfunk-Information service (ARI, German for Automotive-Driver's-Broadcasting-Information).
It was used as an indicator for traffic announcements.
It is now obsolete and is replaced by the more modern Radio Data System (RDS).
However, the Hinz Triller is still transmitted in many radio stations and can often be heard before and after the traffic announcements \cite{HinzTriller}.
In the implemented transmitter, the Hinz Triller is implemented, but is disabled, since it only represents a temporarily transmitted signal.

The Radio Data System (RDS) signal is not implemented in the transmitter, since it consists of a comprehensive protocol and multiple steps of modulation, such as differentially-coded BPSK \cite{IntroFmStereoRdsModulation} and is therefor too time-consuming to implement.
Furthermore, it would not contribute any additional value to this project, since this is not the main focus.

At this point in the DSP chain, the signal resembles the frequency spectrum of Fig.\ref{fig:fm_channel_baseband_freqs}.

In the final chain of DSP blocks, the sample rate is increased again, to be able to frequency-modulate the signal.
The resulting frequency modulated signal represents the signal that is received by an antenna - the RF signal of an FM channel.
This signal is then processed by a complex baseband mixer, which results in inphase-, and quadrature components in the baseband.
An LP filter band-limits the signal and removes artifacts of the mixer.
As a final step, the sample rate is decreased again, back to the chosen sampling rate of 960 kHz.

This signal can now be processed in a digital FM receiver.

\subsection{Pre-Emphasis and De-Emphasis}
show effects in spectrum, show how to design the filters

\subsection{Fixed Point Arithmetic}
not developed in actual fixed point, but close to hardware level algorithm




\section{GNU Radio}
  \subsection{Introduction}
  \subsection{Transmitter}
  \subsection{Receiver}

\section{VHDL (no shortcut)}
  \subsection{Testbench}
  \subsection{Channel Selection (IF to Channel-BB)}
  \subsection{Phase Detector}
  \subsection{other Elements}

  \section{High-Level Synthesis}
  \subsection{Testbench}
  \subsection{Channel Selection (IF to Channel-BB)}
  \subsection{Phase Detector}
  \subsection{other Elements}

\section{Common Testbench}
  \subsection{Architecture (same tb for VHDL and HLS-generated HDL)}
  \subsection{Framework cocotb, with ghdl compiler}
  Instantiate both HDL models in the testbench.\\
  Display a direct comparison of outputs in graphs. This is practical, since the cocotb framework runs in python and graphs can be generated using Python's matplotlib.

