%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
\label{cha:Implementation}

This chapter describes the most important details of each implementation variant.

\section{Digital Signal Processing Chain}

The theory behind the demodulation of an FM signal is already explained in Chapter \ref{cha:SignalProcessingTheory}.
The demodulation of an FM broadcast channel specifically, is described in Section \ref{sec:demodulation-of-broadcast-fm}.
In this section however, the DSP chain is described into more detail and with more information, as it is implemented in the various methods.\\

Fig.\ref{fig:bd_dsp_detailed} displays the detailed DSP chain as a block diagram.

\includepicture [1.02] [0] [H] {Detailed block diagram of the digital signal processing chain.} {bd_dsp_detailed} {img/draw.io/bd_dsp_detailed}

The following list explains implementation details about the respective DSP blocks.
\begin{itemize}
  \item \textbf{Data Source}\\
      Matlab is used to generate the data source file, which is used as an input to the system.
      An audio file is read and modulated as an FM channel signal.

  \item \textbf{FM Demodulator}\\
      The FM demodulator is implemented as a Baseband Delay Modulator, as described in Section \ref{sec:BasebandDelayDemodulator}.

  \item \textbf{De-Emphasis Filter}\\
      The above described Matlab source generation does not include an Emphasis filter.
      Thus, a de-emphasis filter is not implemented as it is not required.

  \item \textbf{Downsample}\\
      Downsampling is implemented in a simplified version, without an anti-aliasing filter.
      It is not required, because of the following explanation.
      At this point the sampling frequency is set to 960 kHz.
      The input is band-limited at 75 kHz, which is the maximum frequency in an FM channel, as explained in Section \ref{sec:FrequencySpectrumOfABroadcastFmChannel}.
      Thus, the input has an oversampling rate of 12.8, while downsampling is only performed with a factor of 8.

  \item \textbf{Filters}\\
      Several filters are implemented as FIR filters.
      The 15 kHz lowpass (LP) filter is instantiated twice, with the exact same coefficients.

  \item \textbf{Filter Group Delay Compensation}\\
      FIR filters introduce a delay on the output signal, with respect to the input.
      The group delay in number of samples can be computed with the following formula.
      \begin{equation}
        group\ delay = \frac{filter\ order}{2} = \frac{(N\ coefficients - 1)}{2}
      \end{equation}
      This is due to the property of the FIR filters' linear phase response \cite{GaziOrhan2018UDSP}.
      Since phase is directly proportional to time, the term \textit{group delay} is often used.
      This delay needs to be accounted for, depending on where the signal is used subsequently.

      Looking at the block diagram, the group delay needs to be compensated at two places.
      \begin{itemize}
        \item \textbf{Between the branches \textit{Recover LR diff} and \textit{Recover Mono}:}\\
          The \textit{Mono} branch only contains a single LP filter, while the \textit{LR diff} branch contains two filters, namely a BP and an LP filter.
          The latter branches' signal is therefore delayed, with respect to the \textit{Mono} branch.\\
          The issue here is, that both signals are added and substracted at the end of the processing chain, to compute the left and right channel signals, respectively.
          Thus, they need to be aligned in time at that point.
          Consequently, a delay block needs to be inserted in the \textit{Mono} branch, to compensate the group delay of the BP.

        \item \textbf{Between the branches \textit{Recover LR diff} and \textit{Recover Carriers}:}\\
          Both branches only contain a single BP filter.
          However, they have properties, like the transition bandwidth and the passband.
          Thus, their filter order may be different as well, which leads to a non-matching group delay.
          Since the two signals are multiplicated in the subsequent mixer, and an important factor is the phase-coherency of the recovered carrier (as explained in Section \ref{sec:demodulation-of-broadcast-fm}), the group delay compensation becomes necessary here.\\

          To overcome the issue at this point in the actual hardware implementation, the filters were manually 'tuned' to have a matching order.
      \end{itemize}

  \item \textbf{Carrier Recovery}\\
      The 38 kHz carrier can be recovered from the 19 kHz pilot tone.
      It is important that the recovered carrier is phase-coherent with the received input, as described in Section \ref{sec:demodulation-of-broadcast-fm}.
      This can be achieved, by simply multiplying the pilot tone with itself, which is the way it is implemented here.
\end{itemize}

\noindent
Several of the listed details are implemented, in order to achieve a successful demodulation of the FM signal.

\section{Matlab Model}

Matlab is used to create a model of the receiver, which is used as a reference for the other implementation variants.
Here, DSP algorithms are tested and evaluated, to find a method that is suitable to implement in hardware, specifically in an FPGA.

The Matlab script consists of a transmitter, the receiver model, and additional code for analysis.

\subsection{Transmitter}

The transmitter is implemented to provide a reproducable source of data, which can be used to feed the receiver.
Another option would be to use external hardware as a software-defined radio and record some antenna data.
However, the main advantage of a locally implemented transmitter over a recording is, that the raw data input is known.
Thus, the expected output of the receiver model is this raw data, that was previously modulated by the local transmitter.
In the case of a recording, the original data is not known, which does not allow to actually verify the receiver.\\

In the implemented version, an audio file is modulated into the FM channel.
The audio file contains data that represents speech with the words \textit{'Left channel... Right channel...'}.
In terms of audio channels, the words exactly match the respective channels' output - the first part is modulated on the left audio channel only, while the second part only targets the right audio channel.
This is particulary useful for verification, especially to verify the functionality of channel separation.
From the experience during development, the channel separation is a good indicator of whether the system is functioning correctly.
This left-right indication also simplifies the verification process, because a developer can recognize it with their visual and acoustic senses.
It is possible to audibly verify it by listening to the output.
It is also possible to just visually inspect the the output data, where a clear separation is visible.

A block diagram of the transmitter structure is depicted in Fig.\ref{fig:bd_matlab_transmitter}.

\includepicture [1.0] [0] [H] {Block diagram of the implemented transmitter in Matlab.} {bd_matlab_transmitter} {img/draw.io/bd_matlab_transmitter}

\subsection{Emphasis and De-Emphasis}
show effects in spectrum, show how to design the filters

\subsection{Fixed Point Arithmetic}
not developed in actual fixed point, but close to hardware level algorithm




\section{GNU Radio}
  \subsection{Introduction}
  \subsection{Transmitter}
  \subsection{Receiver}

\section{VHDL (no shortcut)}
  \subsection{Testbench}
  \subsection{Channel Selection (IF to Channel-BB)}
  \subsection{Phase Detector}
  \subsection{other Elements}

  \section{High-Level Synthesis}
  \subsection{Testbench}
  \subsection{Channel Selection (IF to Channel-BB)}
  \subsection{Phase Detector}
  \subsection{other Elements}

\section{Common Testbench}
  \subsection{Architecture (same tb for VHDL and HLS-generated HDL)}
  \subsection{Framework cocotb, with ghdl compiler}
  Instantiate both HDL models in the testbench.\\
  Display a direct comparison of outputs in graphs. This is practical, since the cocotb framework runs in python and graphs can be generated using Python's matplotlib.

