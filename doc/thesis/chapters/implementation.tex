%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
\label{cha:Implementation}

This chapter describes the most important details of each implementation variant.
The implementation variants in High-Level Synthesis and VHDL are highlighted especially, since they are the main focus of this thesis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Digital Signal Processing Chain}

The theory behind the demodulation of an FM signal is already explained in Chapter \ref{cha:SignalProcessingTheory}.
The demodulation of an FM broadcast channel specifically, is described in Section \ref{sec:demodulation-of-broadcast-fm}.
In this section however, the DSP chain is described into more detail and with more information, as it is implemented in the various methods.\\

Fig.\ref{fig:bd_dsp_detailed} displays the detailed DSP chain as a block diagram.

\includepicture [1.02] [0] [H] {Detailed block diagram of the digital signal processing chain.} {bd_dsp_detailed} {img/draw.io/bd_dsp_detailed}

The following list explains implementation details about the respective DSP blocks.
\begin{itemize}
  \item \textbf{Data Source}\\
      Matlab is used to generate the data source file, which is used as an input to the system.
      An audio file is read and modulated as an FM channel signal.

  \item \textbf{FM Demodulator}\\
      The FM demodulator is implemented as a Baseband Delay Modulator, as described in Section \ref{sec:BasebandDelayDemodulator}.

  \item \textbf{De-Emphasis Filter}\\
      The above described Matlab source generation does not include an Emphasis filter.
      Thus, a de-emphasis filter is not implemented as it is not required.

  \item \textbf{Downsample}\\
      Downsampling is implemented in a simplified version, without an anti-aliasing filter.
      It is not required, because of the following explanation.
      At this point the sampling frequency is set to 960 kHz.
      The input is band-limited at 75 kHz, which is the maximum frequency in an FM channel, as explained in Section \ref{sec:FrequencySpectrumOfABroadcastFmChannel}.
      Thus, the input has an oversampling rate of 12.8, while downsampling is only performed with a factor of 8.

  \item \textbf{Filters}\\
      Several filters are implemented as FIR filters.
      The 15 kHz lowpass (LP) filter is instantiated twice, with the exact same coefficients.

  \item \textbf{Filter Group Delay Compensation}\\
      FIR filters introduce a delay on the output signal, with respect to the input.
      The group delay in number of samples can be computed with the following formula.
      \begin{equation}
        group\ delay = \frac{filter\ order}{2} = \frac{(N\ coefficients - 1)}{2}
      \end{equation}
      This is due to the property of the FIR filters' linear phase response \cite{GaziOrhan2018UDSP}.
      Since phase is directly proportional to time, the term \textit{group delay} is often used.
      This delay needs to be accounted for, depending on where the signal is used subsequently.

      Looking at the block diagram, the group delay needs to be compensated at two places.
      \begin{itemize}
        \item \textbf{Between the branches \textit{Recover LR diff} and \textit{Recover Mono}:}\\
          The \textit{Mono} branch only contains a single LP filter, while the \textit{LR diff} branch contains two filters, namely a BP and an LP filter.
          The latter branches' signal is therefore delayed, with respect to the \textit{Mono} branch.\\
          The issue here is, that both signals are added and substracted at the end of the processing chain, to compute the left and right channel signals, respectively.
          Thus, they need to be aligned in time at that point.
          Consequently, a delay block needs to be inserted in the \textit{Mono} branch, to compensate the group delay of the BP.

        \item \textbf{Between the branches \textit{Recover LR diff} and \textit{Recover Carriers}:}\\
          Both branches only contain a single BP filter.
          However, they have properties, like the transition bandwidth and the passband.
          Thus, their filter order may be different as well, which leads to a non-matching group delay.
          Since the two signals are multiplicated in the subsequent mixer, and an important factor is the phase-coherency of the recovered carrier (as explained in Section \ref{sec:demodulation-of-broadcast-fm}), the group delay compensation becomes necessary here.\\

          To overcome the issue at this point in the actual hardware implementation, the filters were manually 'tuned' to have a matching order.
      \end{itemize}

  \item \textbf{Carrier Recovery}\\
      The 38 kHz carrier can be recovered from the 19 kHz pilot tone.
      It is important that the recovered carrier is phase-coherent with the received input, as described in Section \ref{sec:demodulation-of-broadcast-fm}.
      This can be achieved, by simply multiplying the pilot tone with itself, which is the way it is implemented here.
\end{itemize}

\noindent
Several of the listed details are implemented, in order to achieve a successful demodulation of the FM signal.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Matlab Model}

Matlab is used to create a model of the receiver, which is used as a reference for the other implementation variants.
Here, DSP algorithms are tested and evaluated, to find a method that is suitable to implement in hardware, specifically in an FPGA.

The Matlab script consists of a transmitter, the receiver model, and additional code for analysis.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transmitter}

The transmitter is implemented to provide a reproducable source of data, which can be used to feed the receiver.
Another option would be to use external hardware as a software-defined radio and record some antenna data.
However, the main advantage of a locally implemented transmitter over a recording is, that the raw data input is known.
Thus, the expected output of the receiver model is this raw data, that was previously modulated by the local transmitter.
In the case of a recording, the original data is not known, which does not allow to actually verify the receiver.\\

In the implemented version, an audio file is modulated into the FM channel.
The audio file contains data that represents speech with the words \textit{'Left channel... Right channel...'}.
In terms of audio channels, the words exactly match the respective channels' output - the first part is modulated on the left audio channel only, while the second part only targets the right audio channel.
This is particulary useful for verification, especially to verify the functionality of channel separation.
From the experience during development, the channel separation is a good indicator of whether the system is functioning correctly.
This left-right indication also simplifies the verification process, because a developer can recognize it with their visual and acoustic senses.
It is possible to audibly verify it by listening to the output.
It is also possible to just visually inspect the output data, where a clear separation is visible between the channels.\\

The transmitter is implemented according to the structure that is depicted as a block diagram in Fig.\ref{fig:bd_matlab_transmitter}.
To facilitate an easy understanding of the block diagram, it is of advantage to keep in mind that it exactly resembles the frequency spectrum that is previously shown in Fig.\ref{fig:fm_channel_baseband_freqs}.\\

\includepicture [1.0] [0] {Block diagram of the implemented transmitter in Matlab.} {bd_matlab_transmitter} {img/draw.io/bd_matlab_transmitter}

The transmitter reads an audio file, including a left and a right channel in the first step.
The audio file contains data in a sample rate of 48 kHz.
Next, the sample rate is increased by an oversampling factor of 20, to achieve a sufficient sample rate for the subsequent DSP procedures.

The achieved sample rate of 960 kHz could actually be chosen much lower, since an FM channels' maximum frequency is 75 kHz (see \ref{sec:FrequencySpectrumOfABroadcastFmChannel}), and according to the Nyquist theorem the sample rate thus only needs to have 150 kHz (see \ref{sec:SamplingTheorem}).
However, the higher rate was chosen, mainly because a higher number of signal samples beautify any plots that are created during analysis.
Since a thorough optimization of the DSP chain is not the focus of this thesis, this was an acceptable trade-off.

The next step is the pre-emphasis filter, which is implemented, but is disabled in the receiver.
This is done to reduce some complexity in the hardware implementation.
The following stage generates the Mono and LR Diff signals, by simply calculating the summation and diffence of the left and right channels, respectively.

The next section in the block diagram represents multiple processes in parallel.
The LR Diff part is shifted to 38 kHz in the spectrum.
This is done by modulating the signal with its sub-carrier of 38 kHz.
A subsequent BP filter serves to remove the artifacts of the modulation, such as the image replica.
It band-limits the spectrum of the LR Diff part between 23 and 53 kHz.
The BP filter introduces a constant group delay of the signal.
In order to maintain the alignment of all signals, this side-effect needs to be accounted for and be compensated in the other signal branches.
Thus, the Mono signal, as well as the Pilot Tone need to be delayed by the amount of samples defined by the BP filters' group delay.
The subsequent amplifier blocks create the defined proportions of the sub-band, such as 90\% for the audio parts, and 10\% for the Pilot Tone \cite{FmMultiplexingForStereo}.

One part in this block diagram is the so-called Hinz Triller, which was part of the Autofahrer-Rundfunk-Information service (ARI, German for Automotive-Driver's-Broadcasting-Information).
It was used as an indicator for traffic announcements.
It is now obsolete and is replaced by the more modern Radio Data System (RDS).
However, the Hinz Triller is still transmitted in many radio stations and can often be heard before and after the traffic announcements \cite{HinzTriller}.
In the implemented transmitter, the Hinz Triller is implemented, but is disabled, since it only represents a temporarily transmitted signal.

The Radio Data System (RDS) signal is not implemented in the transmitter, since it consists of a comprehensive protocol and multiple steps of modulation, such as differentially-coded BPSK \cite{IntroFmStereoRdsModulation} and is therefor too time-consuming to implement.
Furthermore, it would not contribute any additional value to this project, since this is not the main focus.

At this point in the DSP chain, the signal resembles the frequency spectrum of Fig.\ref{fig:fm_channel_baseband_freqs}.

In the final chain of DSP blocks, the sample rate is increased again, to be able to frequency-modulate the signal.
The resulting frequency modulated signal represents the signal that is received by an antenna - the RF signal of an FM channel.
This signal is then processed by a complex baseband mixer, which results in inphase-, and quadrature components in the baseband.
An LP filter band-limits the signal and removes artifacts of the mixer.
As a final step, the sample rate is decreased again, back to the chosen sampling rate of 960 kHz.

This signal can now be processed in a digital FM receiver.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Pre-Emphasis and De-Emphasis}
TODO: show effects in spectrum, show how to design the filters

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Fixed Point Arithmetic}

The target hardware platform of the FM radio receiver project is an FPGA.
These are devices that have a limited number of logic cells, which can be used to implement logical and computational functions.
Any kind of computation can be implemented within these logic cells.
However, depending on its detailed implementation, the amount of required logic cells may differ by a large factor.
In order to overcome this issue, mathematical operations are often implemented in fixed point arithmetic, rather than floating point.
This is due to the fact, that fixed point operations can be implemented with much less logic cells than floating point operations.
The reason therefor is, that the bitwidth of input and output numbers is previously known in fixed point.
Floating point calculations do not have this assumption and thus need to be more flexible, which requires a larger amount of logic cells.\\

The Matlab model is therefore developed by keeping in mind this limitation.
Matlab provides special datatypes for fixed point number representation.
However, these were not used in this implementation.
Instead, everything is calculated in floating point representation, using the standard \textit{double} datatype.
Then, in certain positions in the DSP chain, the numbers are rounded to the resolution of a fixed point datatype.
A fixed point format of \textit{2.14}, meaning 2 bit for integer- and 14 bit for fractional number representation is chosen.
This is sufficient for the FM receiver and could potentially be lowered to a lower bitwidth.
Again, an optimization of the DSP chain is not the focus of this thesis.\\

Summing up, the Matlab model is not implemented in fixed point arithmetic, but is implemented in a way, that is close enough to the hardware implementation.
Therefore, it can serve as a reference for the hardware implementation.


%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Receiver}

The receiver is implemented, following the block diagram in Fig.\ref{fig:bd_dsp_detailed}.
Further assumptions and simplifications, such as the fixed point arithmetic are described into detail above.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Analysis}

The Matlab implementation also includes a comprehensive range of analysis, especially in terms of visual plots.
These plots are useful during the development of new DSP algorithms, in order to verify the correct thereof.\\

An example of a plot that is created by the analysis is depicted in Fig.\ref{fig:matlab_analysis_time_domain}.
The diagram shows the respective signals in the time domain.
Above two timelines display the input data, as it is read from the input audio file.
The two diagrams in the center plot the Mono and LR Diff signals.
The bottom diagrams then represent the result after the entire signal processing chain.
It can be seen that the DSP chain is not able to demodulate the original signal without any error.
However, the result shows a clear separation of the left and right channels, as resembles the original input very closely, which is good enough for this case study.\\

\includepicture [1.0] [0] {Matlab analysis in the time domain.} {matlab_analysis_time_domain} {img/matlab/matlab_analysis_time_domain}

Further analysis is done in the frequency domain, especially in order to better understand the modulation of the different spectral parts in the FM channel.
An example thereof is shown in Fig.\ref{fig:matlab_analysis_freq_domain}.

The spectrum of an FM channel, as it is generated by a transmitter before the modulation, is shown in the upper diagram.
The spectrum after the demodulation through a receiver is shown in the lower diagram.
Spectral parts, such as the pilot tone at 19 kHz, or the LR Diff part around 38 kHz can be seen clearly.
The demodulated spectrum shows an artifact at 57 kHz, which does not exist in the original transmitter spectrum.
This is an artifact of the demodulation process, specifically the frequency-shift of the LR Diff part to baseband.
The artifact is very low in energy, because it is attenuated by a BP filter in the down-conversion process, and can thus be ignored for further processing, even though it can still be seen in the spectral analysis.

\includepicture [1.0] [0] {Matlab analysis in the frequency domain.} {matlab_analysis_freq_domain} {img/matlab/matlab_analysis_freq_domain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{GNU Radio}

This section describes the implementation in GNU Radio.
A transmitter, as well as a receiver are implemented using this software.
Both can be deployed on actual hardware, so a continuous transmitter or receiver is built in a real environment.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Introduction}

GNU Radio is a free and open-source software development toolkit to implement a software-defined radio.
The implementation is done by connecting functional blocks in a block design.
This abstracts the inner workings of each functional block and thus provides an implementation approach on a very high level of abstraction.
GNU Radio supports interfaces to external RF hardware \cite{SoftwareGnuRadio}.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{External Hardware}

In order to interface with the real world, two different hardware devices are used.
Both devices are supported by GNU Radio and are briefly described here.

\subsubsection{USRP b200mini}

The USRP b200mini is a device that can be used to create a software-defined radio.
It resembles the size of a business card and is developed by Ettus Research.
A signal range from 70 MHz to 6 GHz can be covered by the front end.
The board further features a Xilinx Spartan-6 FPGA that is user-programmable, which makes the device very flexible for various applications with the received signal \cite{USRPb200Mini}.

GNU Radio supports this device with the blocks \textit{UHD: USRP Sink} and \textit{UHD: USRP Source}.
Therefore, it can be used as both a receiver and a transmitter.

\subsubsection{RTL-SDR}

The RTL-SDR is a cheap USB dongle, that was originally developed as a DVB-T TV tuner.
It is based on the RTL2832U chipset, which includes an 8-bit ADC and a digital signal processor.
The device delivers IQ data via the USB interface \cite{RTLSDR}.

Based on its hardware, the RTL-SDR can only be used as a receiver.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transmitter}

GNU Radio provides a comprehensive set of DSP blocks, which are available to build various functionalities.
Multiple blocks are connected to a block diagram, that is very similar to the one in Fig.\ref{fig:bd_matlab_transmitter}.
The USRP device is used to broadcast the RF signal over the air.

Again, an audio file is used as an input, which is modulated as an FM channel signal.
The entire multiplex signal is then modulated onto an actual carrier frequency of 99 MHz, that is within the FM radio broadcast band.
This entire DSP chain is being run in the GNU Radio software, on a host PC.
Only the final signal - FM modulated, and on a carrier of 99 MHz - is then sent to the USRP device in the form of digital signal samples.
The USRP hardware then transmits the signal via its antenna.\\

\noindent
Special care needs to be taken when transmitting signals over the air.
The frequency spectrum is strongly limited by the radio regulations and may be monitored by the authorities.
Please make sure to adapt your setup to the respective local regulations, to avoid any legal issues.
Some of the regulations are mentioned in \ref{sec:FrequencyBand}, but may differ in various countries, however.

Fig.\ref{fig:bd_gnuradio_setup_transmitter} shows a block diagram of the transmitter application.

\includepicture [0.9] [0] [H] {Block diagram of the GNU Radio transmitter setup.} {bd_gnuradio_setup_transmitter} {img/draw.io/bd_gnuradio_setup_transmitter}


%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Receiver}

The receiver is also implemented, by using standard DSP blocks that are available in GNU Radio.
The implemented structure however does not represent a stereo receiver.
Instead, a mono receiver is implemented.
The antenna signal is FM-demodulated, decimated and then directly sent to the speakers as the output, without any further processing.
This simple receiver was intended as a proof-of-concept and a first example of the cooperation of the external hardware and the GNU Radio software.
Thus, the mono receiver was sufficient, as the focus of the GNU Radio application is put on the transmitter side.

This receiver works with both devices, the USRP b200mini and the RTL-SDR.

Fig.\ref{fig:bd_gnuradio_setup_receiver} shows a block diagram of the receiver application.

\includepicture [0.9] [0] [H] {Block diagram of the GNU Radio receiver setup.} {bd_gnuradio_setup_receiver} {img/draw.io/bd_gnuradio_setup_receiver}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{System Level Integration for Verification}

The usage of a software like GNU Radio in combination with external hardware is an interesting tool for a use-case like this project.
An FM receiver is to be implemented in multiple different versions.
All of them need to be verified somehow - this is where the SDR transmitter created with GNU Radio and external hardware opens up an entire new possibility from the viewpoint of system level design integration.\\

Previously it was explained that it is not possible to use recorded antenna data for verification.
The reason was, that the underlying original data is not known and therefor a comparison of the original versus the received, decoded data is not feasible.
Consequently, the Matlab transmitter model was justified by the fact, that its originally encoded audio data is well-known.\\

However, with the current approach of using a GNU Radio SDR transmitter, the encoded data \textit{is} well-known, because it is generated locally.
Thus, the SDR can be used to transmit a verification signal.
This signal could be recorded to file by another SDR, or sourced into the DUT (device under test) directly.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{VHDL (TODO: no shortcut?)}

In this section, the most important details of the VHDL implementation are described.
This implementation variant is one of the two major implementation focus points of this thesis.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simulation Testbench}

The general significance of a simulation testbench in hardware description language (HDL) design is explained here, as well as an introduction to the used testbench framework that is used in this project.

%%%%%%%%%%%%%
\subsubsection{General}

In the development of software that runs on a CPU, the tool of step-by-step debugging is commonly used during the development process.
Various verification and testing libraries exist, in order to create unit tests, for example.
The advantage is, that the code that is developed there, can be compiled and run on the target CPU directly, while maintaining the direct step-by-step representation of the code.

However, in the development of hardware with any HDL, this is not possible.
HDL languages provide a syntax and semantic representation that allow to create parallel structures and a dependency on timing, such as a system clock.
The design is based on signals that perform logic operations and transfer values into registers.
Thus, HDL code is often called register-transfer level, or short, RTL code.
Before this code can be run on the target hardware, i.e. an FPGA, it needs to run through a process called synthesis.
In synthesis, the HDL code is translated into a netlist and is consequently mapped into hardware logic cells that are available in the target device.
Various optimizations are done during this process, so that the direct connection to the code representation is lost.
Additionally, it is impossible to access every single signal within the design during debugging on the hardware, which is probably also one of the main issues.
Synthesis tools like Xilinx Vivado provide support to make debugging possible in hardware, but require a large effort to implement them, especially in terms of synthesis time.
Another big factor that speaks against debugging in hardware generally, is that the process of synthesis takes a comparably large amount of time to transform code into the target technology.
Each time the code is adapted, the entire synthesis process needs to be started over again.

Because of all these reasons, debugging HDL code step-by-step as in software is not possible.\\

Thus, in order to allow debugging and verification of HDL code, the technology of simulation was invented.
Here, the HDL is also translated into a netlist that represents all the parallel processes just like in hardware, but the subsequent step of synthesis is not taken.
Therefore, simulation comes to a result much faster.
Since HDL designs actually only consist of electrical wires and some basic block primitives, like Flipflops or lookup tables, it is difficult to verify correct values.
They would need to be compared in their binary bit-pattern format, at the correct point in time.
Of course the HDL language provides support with different datatypes, that abstract the binary number representation and make the numbers human-readable.
However, it remains an enormous effort to manually write testing code to verify a bus interface, for example.
In order to simplify such complex operations, various testbench frameworks are available to developers.

%%%%%%%%%%%%%
\subsubsection{Simulator GHDL}

Multiple different simulators are available on the market, such as Mentor Graphics ModelSim or QuestaSim, Synopsys VCS or the Cadence Simulator.
The issue with most simulators is, that they are subject to a license fee, depending on the required set of features, or simulation speed.\\

However, there are simulators available, that are free to use.
An example therefor is GHDL, which is an analyzer, compiler and simulator for VHDL and is developed as an open-source project.
GHDL translates the VHDL code to a binary file that contains machine code, which can be executed.
This is supported for a all common operating systems such as Linux, Windows and macOS.
The simulator further supports a VPI (Verilog Procedural Interface), which can be used to control the simulator \cite{GHDLDoc}.

%%%%%%%%%%%%%
\subsubsection{Framework cocotb}

The testbench framework cocotb is developed as a free, open-source project.
It can be used to verify VHDL and SystemVerilog RTL code, in combination with an external simulator.
Various different simulators can be used with cocotb - amongst others, GHDL is supported.
The interface that is used to the simulator is the industry-standard VPI.\\

One of the main advantages of cocotb is, that test cases for the respective RTL code are written in the language Python.
It is therefore also called a co-simulation framework.
Using Python provides a large factor of flexibility and possibilities, since it is a comprehensive language, considering all its extension libraries.
Additionally, Python may be more familiar to engineers in comparison to VHDL and thus, writing testbenches is made simpler with cocotb.

The test cases in Python are implemented as coroutines.
By the way, the name cocotb is constructed by the words \textit{CO}routine, \textit{CO}simulation and \textit{T}est\textit{B}ench \cite{cocotbDoc}.\\

Fig.\ref{fig:bd_cocotb_interface_simulator} gives an overview of how cocotb interfaces with a simulator.
The Python test cases are shown as a list of coroutines, which are managed by a scheduler.
This Python code interfaces with the simulator through standard interfaces like VPI.
The block called \textit{GPI} is developed by cocotb and abstracts the different simulator interfaces, such as VPI, VHPI or FLI.
In the simulator, the device under test (DUT) is instantiated.
The RTL simulation itself is managed by the simulators' scheduler.

\includepicture [1.0] [0]  {Block diagram of the interface between cocotb and a simulator \cite{cocotbDoc}.} {bd_cocotb_interface_simulator} {img/draw.io/bd_cocotb_interface_simulator}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Channel Selection (IF to Channel-BB)}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Phase Detector}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{other Elements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{High-Level Synthesis}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testbench}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Channel Selection (IF to Channel-BB)}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Phase Detector}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{other Elements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Common Testbench}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Architecture (same tb for VHDL and HLS-generated HDL)}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Framework cocotb, with ghdl compiler}
  Instantiate both HDL models in the testbench.\\
  Display a direct comparison of outputs in graphs. This is practical, since the cocotb framework runs in python and graphs can be generated using Python's matplotlib.

