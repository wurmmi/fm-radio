%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{High-Level Synthesis}
\label{cha:HLS}

This chapter covers High-Level Synthesis in general, but also describes details that specifically apply to Xilinx.
The main sources of information for this chapter are found in \cite{VivadoUgHLSIntro}and \cite{VivadoUgHLS}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In software development, engineers are used to writing code in a high-level language, such as C or \cplusplus.
With these languages, specific hardware details are abstracted and thus, very little knowledge of the target hardware is required.
The compiler takes over these details as it transforms the code by using the underlying, supported instruction set of the target hardware.
This has been the standard for many years by now.
In the earlier times however, it was common practise to develop programs in the low-level assembly language.
The supported instruction set of the target CPU had to be implemented directly by the software engineer.\\

A direct comparison can be drawn to FPGA design.
An FPGA engineer historically develops code in the register-transfer level (RTL), which is common practise until today.
This can be compared to developing software in the assembly language.
However, the recent development towards automation and code generation brought up High-Level Synthesis (HLS).
There, the FPGA design can be described in a high-level language, such as C or \cplusplus, which is convenient and allows to focus on the algorithm, rather than hardware details.
This high-level code is then transformed into the low-level RTL automatically, by the HLS tool.\\

The usage of HLS tries to bring software- and hardware development closer together and tries to make these two worlds more similar.
In software development, there are different compilers for multiple processor architectures, which can be used to port a program to another target hardware.
The idea of HLS is to create the same level of abstraction - write code in a high-level language, which is agnostic of its target hardware architecture.\\

A major achievement in the usage of HLS is the shorter development time.
The time that it takes to develop a first working version of the intended design can be significantly reduced, compared to the development in RTL code directly.
This is especially important when an FPGA design is combined with a software part, like in a System On Chip, since software development is comparably fast.
Fig.\ref{fig:timeline_performance_first_prototype} schematically displays the difference in development time, over performance and degree of optimization, when the same functionality of a prototype is implemented in different methods for various targets.
The compared targets are an x86 processor CPU, a digital signal processor (DSP), a graphics processing unit (GPU) and the FPGA design in RTL or HLS implementation.
It is clearly visible, that the FPGA design with the HLS design approach achieves a first working prototype much earlier than the direct RTL approach.

\includepicture [0.8] [0] {Design Time vs. Application Performance, if the same functionality is implemented in different methods for various targets \cite[Figure 1-1]{VivadoUgHLSIntro}.} {timeline_performance_first_prototype} {img/timeline_performance_first_prototype}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{State Of The Art}

- usage in percentage (market share), compared to direct RTL coding\\

-  Language Support\\
\cplusplus and SystemC\\
In the latest Xilinx HLS tools 'Vitis HLS' and 'Vivado HLS', the language SystemC is already deprecated \cite{VivadoHlsSystemC}.\\

- efficiency (see \cite[II.C.: State of the Art]{CompareHlsVHDLArticle})\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Functionality}

transform high-level code to HDL.\\
-analysis\\
-scheduling\\
-pipelining\\

- Limitations\\
dynamic memory allocation, etc.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Workflow}

see Chapter "Software Verification and Vivado HLS" of \cite{VivadoUgHLSIntro}

- recommended to use software verification tools, like valgrind or Coverity (dynamic code checker)\\
- use code coverage with e.g. gcov for testbench

general workflow:
- develop c/c++\\
- verify it using above mentioned software tools \\
- HLS testbench it (c-sim)\\
- transform to RTL\\
- HLS testbench it (co-sim)\\
- integrate the generated RTL to a larger FPGA design\\
- synthesize FPGA bitstream\\
- use on FPGA\\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coding}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Compiler Directives (\#pragma's)}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Data types}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Functions}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loops}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Conditional statements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Testbench}

An HLS testbench can be executed in different levels of abstraction, which is a major difference between a VHDL testbench and an HLS testbench.
The most important impact thereof is the execution speed - the time it takes to simulate a number of test cases on the DUT.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C Simulation}

In C Simulation, the HLS compiler is used to create an executable binary that includes the testbench code, as well as the IP design of the DUT.
This binary can be run just like any other program.
The most important note here is, that the HLS code is \textit{not} transformed into RTL at this point.
Instead, the HLS code is treated as a regular \cplusplus\ code, that uses some libraries, like the fixed-point library.
This means, that the HLS IP cores' top-level function is used as a regular function call in the testbench.\\

The main advantage of this type of simulation is the major increase of execution speed.
The reason for this speed-up is the abstraction of timing, such as clock cycles or similar constraints.
In fact, there is absolutely no timing information that needs to be taken into account in this simulation.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C/RTL Co-Simulation}

This type of simulation actually transforms the HLS IP code into RTL code, such as Verilog or VHDL, for the testbench.
This is done in three steps.\\

\begin{itemize}
  \item \textbf{Create input vectors}\\
  In this first step, the above explained, regular C simulation is executed.
  Hereby, the inputs that are sent to the DUT are stored as 'input vectors'.

  \item \textbf{Perform RTL simulation}\\
  Next, the previously generated input vectors are applied to the DUT.
  At this point, the DUT is already translated into RTL code, so the code that is used here is either VHDL or Verilog code.
  The default simulator is the Vivado Simulator (XSim).
  However, various other simulators like ModelSim are supported.
  The generated outputs of this step are stored as 'output vectors'.
  \item \textbf{Verify the results}\\
  The final verification step sources the output vectors back to the C testbench, which compares the outputs with the expected results.\\
\end{itemize}

\noindent
This type of simulation takes a significantly longer time to execute, because timing information now actually needs to be considered for the RTL code.
