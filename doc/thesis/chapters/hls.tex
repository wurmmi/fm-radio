%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{High-Level Synthesis}
\label{cha:HLS}

This chapter covers High-Level Synthesis in general, but also describes details that specifically apply to Xilinx.
The main sources of information for this chapter are found in \cite{VivadoUgHLSIntro}and \cite{VivadoUgHLS}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In software development, engineers are used to writing code in a high-level language, such as C or \cplusplus.
With these languages, specific hardware details are abstracted and thus, very little knowledge of the target hardware is required.
The compiler takes over these details as it transforms the code by using the underlying, supported instruction set of the target hardware.
This has been the standard for many years by now.
In the earlier times however, it was common practise to develop programs in the low-level assembly language.
The supported instruction set of the target CPU had to be implemented directly by the software engineer.\\

A direct comparison can be drawn to FPGA design.
An FPGA engineer historically develops code in the register-transfer level (RTL), which is common practise until today.
This can be compared to developing software in the assembly language.
However, the recent development towards automation and code generation brought up High-Level Synthesis (HLS).
There, the FPGA design can be described in a high-level language, such as C or \cplusplus, which is convenient and allows to focus on the algorithm, rather than hardware details.
This high-level code is then transformed into the low-level RTL automatically, by the HLS tool.\\

The usage of HLS tries to bring software- and hardware development closer together and tries to make these two worlds more similar.
In software development, there are different compilers for multiple processor architectures, which can be used to port a program to another target hardware.
The idea of HLS is to create the same level of abstraction - write code in a high-level language, which is agnostic of its target hardware architecture.\\

A major achievement in the usage of HLS is the shorter development time.
The time that it takes to develop a first working version of the intended design can be significantly reduced, compared to the development in RTL code directly.
This is especially important when an FPGA design is combined with a software part, like in a System On Chip, since software development is comparably fast.
Fig.\ref{fig:timeline_performance_first_prototype} schematically displays the difference in development time, over performance and degree of optimization, when the same functionality of a prototype is implemented in different methods for various targets.
The compared targets are an x86 processor CPU, a digital signal processor (DSP), a graphics processing unit (GPU) and the FPGA design in RTL or HLS implementation.
It is clearly visible, that the FPGA design with the HLS design approach achieves a first working prototype much earlier than the direct RTL approach.

\includepicture [0.8] [0] {Design Time vs. Application Performance, if the same functionality is implemented in different methods for various targets \cite[Figure 1-1]{VivadoUgHLSIntro}.} {timeline_performance_first_prototype} {img/timeline_performance_first_prototype}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{State Of The Art}

Information for this section is found in \cite{EvolutionOfHLS}, \cite{XilinxVivisHLSOpenSource} and \cite{CompareHlsVHDLArticle}.\\

HLS has been developed over 20 years ago, but has not been able to replace the manual, traditional implementation of RTL, using VHDL and Verilog, so far.
Unfortunately, no published numbers about the market share of HLS in relation to traditional implementations could be found during the research in this thesis.
However, according to the given sources it is becoming more and more popular in recent years.
This is mainly based on the fact that the HLS tools keep producing results of better quality as they are developed further.
This especially regards the efficiency of the produced RTL code, the useability of the tools, as well as the better understandable correlation between the high-level code and the generated RTL code.\\

Xilinx is the largest manufacturer of FPGAs globally and therefore its tool 'Xilinx HLS' is widely used.
Intel, the second largest FPGA manufacturer, also has its HLS tool called 'Intel oneAPI' \cite{IntelHLSOneAPI}.
Both companies are conducting serious effort to push the HLS implementation method.
Xilinx recently open-sourced the code for the front-end of their HLS compiler.
The front-end processes the HLS code, specifically \cplusplus, and creates an intermediate representation from it.
The company expects to expand the community engagement and the encouragement of innovation, driven by users, with this step.
Also Intel with its oneAPI toolkit is trying to introduce a wider usage of HLS to the community.\\

In terms of language support, several tools settle for \cplusplus.
Intel oneAPI uses library APIs and DP\cplusplus\ (Data-Parallel \cplusplus), which is an extension to the ISO \cplusplus\ standard.
Xilinx also decided in favor of the \cplusplus\ language for their tools 'Vivado HLS' and 'Vitis HLS'.
In older versions, SystemC was supported for synthesis as well, but is now deprecated in the respective latest versions \cite{VivadoHlsDeprecatesSystemC}.\\

Summing up, HLS is gaining more and more attention as it becomes more efficient.
Its usage is being promoted and pushed forward with serious effort by the major FPGA chip manufacturers and tool vendors.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Functionality}
%
%transform high-level code to HDL.\\
%-analysis\\
%-scheduling\\
%-pipelining\\
%
%- Limitations\\
%dynamic memory allocation, etc.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Workflow}

This section describes the workflow for Xilinx HLS, as it is recommended in the user guide \textit{Introduction to FPGA Design with Vivado High-Level Synthesis} \cite{VivadoUgHLSIntro}.\\

Generally, as the user guide states, the quality and the correctness of the generated output can only be as good as its input.
Consequently, it is very important to follow the design recommendations and adhere to specific rules in order to produce a high-quality input software.\\

The following list presents the main steps that are required in the implementation workflow of an HLS IP core project.\\

\begin{itemize}
  \item \textbf{Software Testbench}\\
      The developed HLS IP code needs to be verified and checked for correct functionality in a software testbench, before it gets processed to RTL code.
      This can be done by using using conventional software development tools.
      Xilinx specifically recommends dynamic code checker tools like \textit{valgrind} or \textit{Coverity}.
      They support a developer in finding memory leaks, out-of-bounds memory access, uninitialized variables and similar issues.
      Furthermore, the application of code coverage tools like \textit{gcov} is recommended as well.
      In that way, the percentage of executed code lines of testbench and HLS code can be measured, to ensure a sufficient level of testing.
      The software testbench is also called 'C Simulation'.\\

      The implementation of the HLS IP code is subject to restrictions.
      As an example, dynamic memory allocation is not supported, since the entire code must be analyzable at runtime to be processed into RTL code.
      %For further details, please read the user guides regarding Xilinx HLS.
      In contrast, the testbench code does not have any restrictions.
      Anything that is supported in C/\cplusplus\ may be used here.\\

  \item \textbf{Co-Simulation}\\
      Co-Simulation serves the purpose verify the correct functionality of the generated RTL code.
      However, the main goal is not to verify the algorithm here.
      This is already done by above described C simulation.


  \item \textbf{integrate the generated RTL to a larger FPGA design}\\
  \item \textbf{synthesize FPGA bitstream}\\
  \item \textbf{use on FPGA}\\
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coding}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Compiler Directives}

e.g. \#pragma's

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Data Types}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Functions}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Loops}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Conditional Statements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Testbench}

An HLS testbench can be executed in different levels of abstraction, which is a major difference between a VHDL testbench and an HLS testbench.
The most important impact thereof is the execution speed - the time it takes to simulate a number of test cases on the DUT.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C Simulation}

In C Simulation, the HLS compiler is used to create an executable binary that includes the testbench code, as well as the IP design of the DUT.
This binary can be run just like any other program.
The most important note here is, that the HLS code is \textit{not} transformed into RTL at this point.
Instead, the HLS code is treated as a regular \cplusplus\ code, that uses some libraries, like the fixed-point library.
This means, that the HLS IP cores' top-level function is used as a regular function call in the testbench.\\

The main advantage of this type of simulation is the major increase of execution speed.
The reason for this speed-up is the abstraction of timing, such as clock cycles or similar constraints.
In fact, there is absolutely no timing information that needs to be taken into account in this simulation.

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{C/RTL Co-Simulation}

This type of simulation actually transforms the HLS IP code into RTL code, such as Verilog or VHDL, for the testbench.
This is done in three steps.\\

\begin{itemize}
  \item \textbf{Create input vectors}\\
  In this first step, the above explained, regular C simulation is executed.
  Hereby, the inputs that are sent to the DUT are stored as 'input vectors'.

  \item \textbf{Perform RTL simulation}\\
  Next, the previously generated input vectors are applied to the DUT.
  At this point, the DUT is already translated into RTL code, so the code that is used here is either VHDL or Verilog code.
  The default simulator is the Vivado Simulator (XSim).
  However, various other simulators like ModelSim are supported.
  The generated outputs of this step are stored as 'output vectors'.
  \item \textbf{Verify the results}\\
  The final verification step sources the output vectors back to the C testbench, which compares the outputs with the expected results.\\
\end{itemize}

\noindent
This type of simulation takes a significantly longer time to execute, because timing information now actually needs to be considered for the RTL code.
